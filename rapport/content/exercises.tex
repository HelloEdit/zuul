\chapter{Exercices}

% The first really interesting exercise to write is 7.5. 
% We initialize our counters to match this situation.
\setcounter{section}{7}
\setcounter{exercise}{4}

\begin{exercise}[subtitle=printLocationInfo]

En ré-usinant le code de l'affichage de la localisation et des sorties en une fonction, on s'assure de ne pas répéter cette partie à plusieurs endroits.

\begin{minted}{java}
private void printLocationInfo() {
    Room vCurrent = this.aCurrentRoom;
    System.out.printf("You are %s%n", vCurrent.getDescription());
   
    System.out.print("Exits: ");
    if (vCurrent.aEastExit != null) System.out.print("east ");
    if (vCurrent.aNorthExit != null) System.out.print("north ");
    if (vCurrent.aSouthExit != null) System.out.print("south ");
    if (vCurrent.aWestExit != null) System.out.print("west ");
    System.out.println();
}
\end{minted}
\end{exercise}

\begin{exercise}[subtitle=getExit]

Dans cet exercice, on se rend compte que le système "un attribut = une sortie" n'est pas le plus optimal (imaginons un hub ayant une dizaines de sorties par exemple, ce qui deviendrait problématique pour la lisibilité et la maintenance du code). L'idée étant de limiter le couplage entre la classe \verb|Room| et les autres classes. Pour cela, on cherchera à limiter la dépendance aux attributs de Room et plutôt passer par une fonction pour récupérer les sorties, ce qui permet de ne gérer la logique des sorties que du côté de \verb|Room|.

\textbf{Notes:} Notons qu'il reste un problème dans \verb|printLocationInfo| à cause de ce changement, problème abordé dans les exercices qui suivent. On peut aussi émettre une critique quant à la façon de fonctionner de \verb|getExit|: si jamais on passe \verb|"North"| à la place de \verb|"north"| par inadvertance, on aura comme valeur de retour \verb|null|. Une solution serait d'utiliser des \verb|enum|.

\begin{minted}{java}
public Room getExit(final String pDirection) {
    switch (pDirection) {
        case "north":
            return this.aNorthExit;

        case "east":
            return this.aEastExit;

        case "south":
            return this.aSouthExit;

        case "west":
            return this.aWestExit;

        default:
            return null;
    }
}
\end{minted}
\end{exercise}

\begin{exercise}[subtitle=getExitString]
Le dernier changement a impacté la façon dont \verb|printLocationInfo| fonctionne. Pour le résoudre, on écrit une nouvelle méthode \verb|getExitString| et, fort de ce changement, on ré-usine \verb|printLocationInfo|.

\begin{minted}{java}
public String getExitString() {
    String vResult = "Exits: ";

    if (this.aEastExit != null) vResult += "east ";
    if (this.aNorthExit != null) vResult += "north ";
    if (this.aSouthExit != null) vResult += "south ";
    if (this.aWestExit != null) vResult += "west";

    return vResult;
}

private void printLocationInfo() {
    Room vCurrent = this.aCurrentRoom;

    System.out.printf("You are %s%n", vCurrent.getDescription());
    System.out.println(vCurrent.getExitString());
}
\end{minted}
\end{exercise}

\begin{exercise}[subtitle=HashMap et setExit]

Maintenant que le couplage entre \verb|Room| et \verb|Game| est faible, on peut remplacer les détails de l'implémentation sans risquer de casser quelque chose. On utilise une structure de données \verb|HashMap| et on doit changer les méthodes de \verb|Room| en conséquence. On en profite aussi pour remplacer \verb|setExits|, devenue inutile, par \verb|setExit|.

\begin{minted}{java}
public Room setExit(final String pDirection, final Room pExit) {
    this.aExits.put(pDirection, pExit);

    return this;
}

public Room getExit(final String pDirection) {
    return this.aExits.get(pDirection);
}
\end{minted}
\end{exercise}

\textbf{Note :} J'ai ajouté en plus de ce que l'exercice demandait la dernière ligne \mintinline{java}{return this;} pour pouvoir chaîner les appels de \verb|setExit| comme ci-dessous:

\begin{minted}{java}
office.setExit("east", car)
      .setExit("north", kitchen)
      .setExit("west", library);
\end{minted}

\begin{exercise}[subtitle=keySet]

\verb|getExitString| doit elle aussi être modifiée. Plutôt que de tester la présence de certaines valeurs dans la \verb|HashMap| (du type "north", "east", "down", "up"...), on peut énumérer les différentes clés qui composent la \verb|HashMap| des sorties.

\begin{minted}{java}
public String getExitString() {
    String vResult = "Exits : ";
    for (String vExit : this.aExits.keySet())
        vResult += vExit + " ";

    return vResult;
}
\end{minted}
\end{exercise}

\begin{exercise}[subtitle=Fonctionnement de keySet et Javadoc]

Reprenons le code intéressant de l'exercice précédent et intéressons-nous à son fonctionnement.

\begin{minted}{java}
for (String vExit : this.aExits.keySet())
    vResult += vExit + " ";
\end{minted}

Ce code marche car \verb|keySet| renvoie un \verb|Set| qui est énumérable et utilisable par la boucle for-each.

La différence entre un \verb|Set| et une liste normale (un tableau) est que le \verb|Set| ne peut pas contenir deux mêmes éléments.

Pour la Javadoc, la documentation de \verb|Game| contient beaucoup moins de méthode que \verb|Room| car l'encapsulation fait que seul \verb|play| est publique pour \verb|Game|, tandis que \verb|Room| doit exposer beaucoup plus de méthodes \verb|public| pour être utilisée par \verb|Game|.

\end{exercise}

\begin{exercise}[subtitle=getLongDescription]

Toujours dans la logique de la conception dirigée par responsabilités, on déplace la création de la description dans la classe \verb|Room|.

\begin{minted}{java}
public String getLongDescription() {
    return "Vous êtes actuellement dans la salle \"" +
            this.aName + "\".\n" +
            this.aDescription + ".\n" +
            this.getExitString();
}
\end{minted}

Et on change \verb|Game| en conséquence.

\begin{minted}{java}
private void printLocationInfo() {
    Room vCurrent = this.aCurrentRoom;
    System.out.println(vCurrent.getLongDescription());
}
\end{minted}
\end{exercise}

\begin{exercise}[subtitle=Diagramme au lancement]
\begin{figure}[ht]

\centering

\begin{tikzpicture}[node distance=2cm and 1cm]

\node [start]                               (game)                  {Game};
\coordinate[below=of game]                  (c);
\node [class, left=of c]                    (room)                  {Room (bureau)};
\node [class, right=of c]                   (parser)                {Parser};
\node [class, below=of c]                   (cmdword)               {CommandWords};
\node [class, below=of c, right=of cmdword] (cmd)                   {Command};

\draw [arrow] (game) to (parser);
\draw [arrow] (game) to (room);
\draw [arrow,dashed] (parser) to node [auto] {va créer sur demande} (cmd);
\draw [arrow] (parser) to (cmdword);

\end{tikzpicture}
\caption{Diagramme de relation entre les objets}
\end{figure}
\end{exercise}

\clearpage

\begin{exercise}[subtitle=Diagramme après go]
\begin{figure}[h]
\centering

\begin{tikzpicture}[node distance=2cm and 1cm]

\node [start]                               (game)                  {Game};
\coordinate[below=of game]                  (c);
\node [class, left=of c]                    (room)                  {Room (vNextRoom)};
\node [class, right=of c]                   (parser)                {Parser};
\node [class, below=of c]                   (cmdword)               {CommandWords};
\node [class, below=of c, right=of cmdword] (cmd)                   {Command (go)};

\draw [arrow] (game) to (parser);
\draw [arrow] (game) to (room);
\draw [arrow, dashed] (parser) to (cmd);
\draw [arrow] (parser) to (cmdword);
\draw [arrow,dashed, bend right=70] (cmd) to node [auto, swap] {est donnée à} (game.east);

\end{tikzpicture}
\caption{Diagramme de relation entre les objets après un go}
\end{figure}
\end{exercise}

\begin{exercise}[subtitle=Commande look]

L'ajout de la commande \verb|look| se traduit par plusieurs changements: le premier en mettant le mot de la commande dans \verb|CommandWords|.

\begin{minted}{java}
// a static constant array that will hold the valid commands words
private final static String[] aValidCommands = 
    { "go", "quit", "help", "look" };
\end{minted}

Il faut aussi modifier \verb|processCommand| en renseignant le nouveau mot de la commande ainsi que la fonction associée.

\begin{minted}{java}
private boolean processCommand(final Command pCommand) {
    if (pCommand.isUnknown()) {
        System.out.println("I don't know what you mean...");
        return false;
    }

    switch (pCommand.getCommandWord()) {
        case "help":
            this.printHelp();
            return false;

        case "quit":
            return this.quit(pCommand);

        case "go":
            this.goRoom(pCommand);
            return false;

        case "look":
            this.look();
            return false;

        default:
            System.out.println("I don't know what you mean...");
            return false;
    }
}
\end{minted}

On remarque aussi que la méthode \verb|look()| fait, pour l'instant, la même chose que \verb|printLocationInfo()|. 
\end{exercise}

\begin{exercise}[subtitle=Commande search]
 
 J'ai choisi d'implémenter une commande nommée \verb|search <something>| qui permettra de fouiller des objet présent dans la pièce où se trouve le joueur. Pour ajouter cette commande, on modifie \verb|CommandWords|.
 
\begin{minted}{java}
private final static String[] aValidCommands = { "go", "quit", "help", "look", "search" };
\end{minted}

Et on doit modifier la méthode \verb|processCommand| de \verb|Game| ainsi que créer la méthode pour gérer cette commande.

\begin{minted}{java}
private boolean processCommand(final Command pCommand) {
    // code omitted for brevity

    switch (pCommand.getCommandWord()) {
        case "inspect":
            this.inspect(pCommand);
            return false;

        // code omitted for brevity
    }
}
\end{minted}

\begin{minted}{java}
private void inspect(final Command pCommand) {
    System.out.printf("Nothing to inspect here.");
}
\end{minted}
\end{exercise}


\begin{exercise}[subtitle=showAll et showCommands]

Dans cet exercice, on rend l'affichage des commandes dans la méthode \verb|printHelp| dynamique en créant un méthode d'énumération des commandes dans \verb|CommandWords|.


\begin{minted}{java}
public void showAll() {
    System.out.print("\t");
    for (String command : CommandWords.aValidCommands) {
        System.out.print(command + " ");
    }
    System.out.println();
}
\end{minted}

\textbf{Note:} On observe que la méthode \verb|showAll| pourrait être déclarée comme \verb|static| car ne dépendant que de \verb|CommandWords.aValidCommands| qui est un attribut statique de la classe \verb|CommandWords|.

On crée aussi un moyen de l'appeler depuis \verb|Game| en passant par \verb|Parser|.

\begin{minted}{java}
// Dans Parser.java
public void showCommands() {
    this.aValidCommands.showAll();
}
\end{minted}

\begin{minted}{java}
// Dans Game.java
private void printHelp() {
    System.out.println("You are lost. You are alone.");
    System.out.println("You wander around at the university.");
    System.out.println("Your command words are:");
    this.aParser.showCommands();
}
\end{minted}
\end{exercise}

\begin{exercise}[subtitle=Changer Game ?]

Malgré toutes nos modifications, si l'on ajoute une nouvelle commande au jeu, il faudra quand même modifier la classe \verb|Game|. En effet, la méthode \verb|processCommand| contient un \verb|switch| dont on doit ajouter une nouvelle branche pour chaque nouvelle commande.

\end{exercise}

\begin{exercise}[subtitle=getCommandList]

Dans cet exercice, on poursuit notre travail sur le modèle de la conception axée sur la responsabilité. Pour le cas de \verb|showAll|, plutôt qu'afficher la liste des commandes disponibles, on préférera générer un \verb|String| pour ne pas imposer un affichage spécifique (notamment via \verb|System.out|).

\begin{minted}{java}
public String getCommandList() {
    String vResult = "";
    for (String command : CommandWords.aValidCommands) {
        vResult += command + " ";
    }

    return vResult;
}
\end{minted}

On modifie la cascade crée aux exercices d'avant pour refléter ce changement.

\begin{minted}{java}
// Dans Parser.java
public String getCommands() {
    return this.aValidCommands.getCommandList();
}
\end{minted}

\begin{minted}{java}
// Dans Game.java
private void printHelp() {
    System.out.println("You are lost. You are alone.");
    System.out.println("You wander around at the university.");
    System.out.println("Your command words are:");
    // "\t" représente une tabulation
    System.out.println("\t" + this.aParser.getCommands());
}
\end{minted}

On en profite aussi pour changer la concaténation des \verb|String| dans les boucles en utilisant \verb|StringBuilder|. Par exemple, sur la boucle dans \verb|Room|.

\begin{minted}{java}
public String getExitString() {
    StringBuilder vResult = new StringBuilder("Exits : ");
    for (String vExit : this.aExits.keySet())
        vResult.append(vExit).append(" ");

    return vResult.toString();
}
\end{minted}

\subsection*{Les objets Room}

Dans l'optique de stocker les instances de \verb|Room| crées, on ajoute un attribut \verb|aAllRooms| qui contiendra tous les objets crées dans \verb|createRooms|. On crée une fonction utilitaire \verb|initRoom| pour nous faciliter la tâche.

\begin{minted}{java}
public class Game {
    private final HashMap<String, Room> aAllRooms;

    private Room initRoom(final String pName, final String pDescription) {
        Room vCurrentRoom = new Room(pName, pDescription);
        this.aAllRooms.put(pName, vCurrentRoom);

        return vCurrentRoom;
    }
}
\end{minted}

\subsection*{zuul-with-images}

Après avoir fait les changements pour intégrer l'interface graphique voulue, on peut s'intéresser à son fonctionnement, notamment à sa gestion des évènements. En effet, dans le code de \verb|UserInterface|, on retrouve cette ligne

\begin{minted}{java}
private void createGUI() {
    // code omitted for brevity
    
    // add some event listeners to some components
    this.aEntryField.addActionListener(this);
}
\end{minted}

Le fait de passer \verb|this| en paramètre indique que c'est la classe courante (soit \verb|UserInterface|) qui va interpréter au moyen d'une méthode \verb|actionPerformed| les évènements venant du \verb|JTextField|. Cela est rendu possible car \verb|UserInterface| implémente l'interface \verb|ActionListener|.

Imaginons que nous voulions implémenter un boutton "Indice" sur le côté droit de l'interface, pour cela, on va devoir modifier \verb|createGUI|.

\begin{minted}{java}
private void createGUI() {
    // code omitted for brevity
    
    // we create a new Button instance...
    JButton vButton = new JButton();
    // ...and we set a special text for it
    vButton.setText("Indice");
    
    // then, we add an action listener for the click event
    vButton.addActionListener(new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent actionEvent) {
            this.giveIndice();
            vButton.setVisible(false); // we allow only one press for this button
        }
    });

    vPanel.setLayout(new BorderLayout());
    // finally, we set this button to the east of the main panel
    vPanel.add(vButton, BorderLayout.EAST);
}
\end{minted}
\end{exercise}

\begin{exercise}[subtitle="MVC"]

L'architecture MVC (signifiant \emph{Modèle-vue-contrôleur}) permet d'organiser son code autour de trois éléments :

\begin{description} 
  \item[La vue] la partie responsable sur l'affichage.
  \item[Le modèle] la partie responsable de gérer les données.
  \item[Le contrôleur] la partie responsable de la logique ainsi que de faire l'intermédiaire entre les données du modèle et l'affichage fait par les vues.
\end{description}

On retrouve cette architecture dans le web (non-exhaustivement, Laravel en PHP, Spring en Java, Express pour node.js etc.), dans la création d'application mobile et bureau...

Ce succès d'utilisation s'explique par le fait que séparer en trois grandes parties l'application permet de mieux se construire une représentation mentale de l'application: chaque élement appartient à un de ces trois groupes. L'un des autres avantages est de minimiser le nombres de modifications à effectuer lorsqu'un changement est nécessaire. On voit bien maintenant pourquoi cette modification pourrait être bénéfique au projet Zuul.

\textbf{Note :} J'ai, pour l'instant, décider de ne pas implémenter le modèle MVC dans mon projet Zuul. Je planifie de refaire l'interface utilisateur du jeu avec \verb|JavaFX| qui force par design l'utilisation d'un pattern MVC.

\subsection*{Image}

On en profite pour déplacer les images de la racine vers un nouveau dossier \verb|Images|.

\begin{minted}{shell-session}
$ mkdir Images
$ mv *.png ./Images
$ ls Images
\end{minted}
\end{exercise}

\begin{exercise}[subtitle=Item]

On crée une classe \verb|Item| avec les accesseurs appropriés pour \verb|description| et \verb|weight|. Ensuite, on va attribuer un item à chaque objet \verb|Room|. Pour cela, on modifie la classe pour ajouter une nouvelle méthode comme ceci :

\begin{minted}{java}
public Room setItem(final String pDescription, final int pWeight) {
    Item vItem = new Item(pDescription, pWeight);
    this.aItem = vItem;
    
    return this;
}
\end{minted}

\textbf{Note :} on rajoute aussi ici un \mintinline{java}{return this;} pour pouvoir chaîner les instructions lors de la création d'un objet \verb|Room|. 
\end{exercise}

\begin{exercise}[subtitle=Item description]

En suivant la logique de cohésion, les informations d'un objet \verb|Item| doit-être généré par \verb|Item| lui-même. La classe en charge d'afficher la description de l'\verb|Item| doit-être \verb|GameEngine|.

\begin{minted}{java}
public String getLongDescription() {
    String vText = String.format(
        "Vous êtes actuellement dans la salle \"%s\"\n%s.\n",
        this.aName,
        this.aDescription
    );

    if (this.aItem == null) vText += "Il n'y a pas d'objet.\n";
    else vText += "Il y a un objet : \"" + this.aItem.getDescription() + "\".\n";

    vText += this.getExitString();

    return vText;
}
\end{minted}

\subsection*{Améliorer la commande look}

Pour améliorer la commande look, on remplace dans \verb|GameEngine| la méthode éponyme.

\begin{minted}{java}
private void look(final Command pCommand) {
    String vToDisplay;

    if (pCommand.hasSecondWord()) {
        Item vItem = this.aCurrentRoom.getItem();
        vToDisplay = (vItem.getDescription().equals(pCommand.getSecondWord()))
                ? vItem.getLongDescription()
                : "Objet inconnu. Rien a afficher\n";
    }
    else {
        vToDisplay = this.aCurrentRoom.getLongDescription();
    }

    this.aGui.println(vToDisplay);
}
\end{minted}
\end{exercise}

\begin{exercise}[subtitle=Items]

On commence par remplacer la définition de la \verb|HashMap| contenue dans chaque \verb|Room|.

\begin{minted}{java}
/**
 * The items of the room.
 */
private final HashMap<String, Item> aItems;
\end{minted}

Puis ensuite on s'intéresse aux erreurs de compilation lié au changement de type.

On utilise ici une collection \verb|HashMap| car on veut établir une relation entre le nom de l'item et l'objet représentant cet item. On n'a pas à parcourir la \verb|HashMap| pour retrouver un item spécifique.
\end{exercise}

\begin{exercise}[subtitle=back]

On va implémenter la commande \verb|back| de façon très naïve : on rajoute un attribut \verb|aPreviousRoom| dans \verb|GameEngine| qui contiendra la salle qui précédait, dans le parcours du joueur, la salle actuelle.

Pour cela, on change la logique de notre commande \verb|go|.

\begin{minted}{java}
private void go(final Command pCommand) {
    if (!pCommand.hasSecondWord()) {
        this.aGui.println("Aller où ?");

        return;
    }

    Room vNextRoom = this.aCurrentRoom.getExit(pCommand.getSecondWord());
    if (vNextRoom == null) {
        this.aGui.println("Cette direction est inconnue...\n");
        return;
    }

    this.changeRoom(vNextRoom);
}
\end{minted}

Et on rajoute en conséquence une méthode pour notre commande \verb|back|.

\begin{minted}{java}
private void back(final Command vCommand) {
    if (vCommand.hasSecondWord()) {
        this.aGui.println("retourner où ??");
        return;
    }

    this.changeRoom(this.aPreviousRoom);
}
\end{minted}
\end{exercise}

\begin{exercise}[subtitle=back test]

En voyant l'implémentation de la commande \verb|back|, le cas singulier de la salle initiale saute aux yeux : en effet, si l'on a pas encore bougé, \verb|aPreviousRoom| est évalué à \verb|null|, pouvant ammener à un \verb|NullPointerException|. On modifie donc \verb|back|.

\begin{minted}{java}
private void back(final Command vCommand) {
    if (this.aPreviousRoom == null) {
        this.aGui.println("Aucune salle dans laquelle retourner.");
        return;
    }
    
    // code omitted for brevity
}
\end{minted}
\end{exercise}

\begin{exercise}[subtitle=back back]

Exécuter deux commandes \verb|back| nous fait retourner à la salle de départ, celle où ce situait le joueur lors de la première commande \verb|back|. Ce problème est inhérent à l'implémentation faite de la commande \verb|back|, notamment du fait que lors de l'exécution de \verb|back|, la salle dans \verb|aPreviousRoom| va dans \verb|aCurrentRoom| et un second \verb|back| fait exactement le contraire !

\end{exercise}

\begin{exercise}[subtitle=Stack]

Pour résoudre le problème évoqué à l'exercice précédent, on va utiliser une collection \verb|Stack| dans l'attribut \verb|aPreviousRooms|. Les deux fonctions qui nous intéressent sur \verb|Stack| sont \verb|push| \verb|pop()|, permettant respectivement d'insérer un élément en haut de la pile et de récupérer l'élément le plus haut de la pile. Ainsi, on change \verb|go| et \verb|back| pour refléter ce changement.

\begin{minted}{java}
private void go(final Command pCommand) {
    // code omitted for brevity
    
    this.aPreviousRooms.push(this.aCurrentRoom);
    this.changeRoom(vNextRoom);
}
\end{minted}

Pour ne pas faire de régression (et faire en sort que Java ne soulève pas une exception \verb|EmptyStackException|), on va tester à chaque appel de \verb|back| si \verb|aPreviousRooms| est vide.

\begin{minted}{java}
private void back(final Command vCommand) {
    // code omitted for brevity
    
    if (this.aPreviousRooms.isEmpty()) {
      this.aGui.println("Aucune salle dans laquelle retourner.");
      return;
    }
    
    Room vPreviousRoom = this.aPreviousRooms.pop();
    this.changeRoom(vPreviousRoom);
}
\end{minted}
\end{exercise}
