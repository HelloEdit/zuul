\documentclass[a4paper,12pt]{report}
\usepackage[T1]{fontenc} % font encodings
\usepackage[utf8]{inputenc} % use utf8 as encoding
\usepackage{lmodern} % use Latin Moderna
\usepackage[french]{babel} % set french as language
\usepackage{graphicx} % manipulate image
\usepackage{hyperref} % use hyper reference
\usepackage{minted} % syntax highlighting
\usepackage[use-files]{xsim} % exercise helper
\usepackage{titlesec} % manipulate title
\usepackage{xcolor} % manipulate color
\usepackage{enumitem} % better list

\definecolor{bg}{rgb}{0.95,0.95,0.95}
\setminted[java]{breaklines,linenos,autogobble,bgcolor=bg}
\setmintedinline[java]{bgcolor={}}


\newcommand\addsubsec[1]{%
  \section*{#1}%
  \addcontentsline{toc}{section}{\GetExerciseProperty{counter}}%
}

% remove useless formating of chapter
\titleformat{\chapter}
  {\normalfont\LARGE\bfseries}{\thechapter}{1em}{}
\titlespacing*{\chapter}{0pt}{3.5ex plus 1ex minus .2ex}{2.3ex plus .2ex}

\hypersetup{colorlinks=true}

\xsimsetup{
  exercise/the-counter = \arabic{section}.\arabic{exercise}, % for "Exercice <section>.<number>
  exercise/heading=\addsubsec
}

\begin{document}
\begin{titlepage}
	\centering
	\includegraphics[width=0.15\textwidth]{../media/murphy.png}\\
	\vspace{1cm}
	{\scshape\LARGE ESIEE Paris \\}
	\vspace{2.5cm}
	{\huge\bfseries Rapport projet Zuul\\}
	\vspace{2cm}
	{\Large Corentin POUPRY\\}
	\vfill
	supervisé par\\
	Denis Bureau

	\vfill
	
	{\large 2020 - 2021\\}
\end{titlepage}

\tableofcontents


\chapter{Présentation}

\section{Auteur}

\noindent
Corentin POUPRY, étudiant à l'ESIEE Paris en E1, promotion 2025.

\section{Thème}

\noindent
Murphy Law, un détective, doit faire la lumière sur l'enquête confiée.

\section{Résumé du scénario}

Vous vous attendiez à tomber sur un super jeu de science-fiction proposé par un étudiant talentueux. Cependant, la réalité est tout autre et vous vous retrouvez au bureau d'un curieux détective. Ce détective, bien décidé à vous aider à faire la lumière sur votre cas atypique, c'est Murphy Law, et c'est lui qu'on appelle quand tout va mal.

\section{Scénario détaillé}

Le Joueur (notons la majuscule) est un personnage à part entière de l'histoire, bien que l'utilisateur joue au travers de Murphy Law. Le Joueur apparaît au début de la narration complètement perdu et à la recherche du jeu de science-fiction promis par le talentueux étudiant dans son rapport. Murphy Law, détective, se demande par quel moyen Le Joueur a pu arriver dans son agence alors que, manifestement, il ne fait même pas partie du schéma narratif du jeu. Quelque chose cloche, quelque chose ne tourne pas rond.\\

Murphy Law décide de partir mener l'enquête en allant voir une source pouvant l'aider dans cette enquête. Avec Le Joueur, il monte dans sa voiture (voir \hyperlink{section.1.6}{Plan}), cependant, la structure du jeu commence à se corrompre, à changer dangereusement sans raison, provoquant la stupéfaction chez les deux protagonistes. Murphy accélère pour semer les incohérences de narration. Alors qu'ils roulent vers leur contact à toute allure, Murphy commence à perdre le contrôle de la situation jusqu'à qu'un arbre apparaisse devant la voiture provoquant un accident.\\

Murphy Law et Le Joueur se réveille dans un grand escalier avec des dorures et un dôme magnifique surmontant la pièce. Après l'irruption d'un majordome disant qu'on les cherche partout, Murphy et Le Joueur réalisent qu'ils passé dans l'univers d'un autre jeu de la promotion, se passant à Buckingham Palace. 

Après avoir perdu le joueur et flairant que quelque chose se trame dans son dos, Murphy Law décide alors de se rendre là où tout a commencé : dans la salle de l'ESIEE où Le Joueur avait lancé le jeu. S'en suit une confrontation avec Le Compilateur, qui essayait de manipuler le jeu à sa guise. Murphy en ressort gagnant.\\

\section{Commandes}

\begin{description}[leftmargin=!,labelwidth=\widthof{\bfseries inspect \textit{objet}}]
  \item [go \textit{direction}] Déplace le personnage vers une certaines pièce.
  \item [look] Affiche la position actuelle ainsi que la description de la pièce.
  \item [inspect \textit{objet}] Permet d'inspecter un objet présent dans la pièce.
  \item [help] Affiche un bref résumé ainsi que la position actuelle.
  \item [quit] Quitte le jeu.
\end{description}

\section{Plan}

\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{../media/map.png}\\

\section{Détail des lieux, items, personnages}

\subsection{Lieux}

Seuls les lieux importants à l'avancement et à l'histoire du jeu sont listés ci-dessous.

\begin{description}[leftmargin=!,labelwidth=\widthof{\bfseries Bureau de Murphy}]
  \item [Bureau de Murphy] C'est le lieu où vous commencez votre aventure.
  \item [Voiture] La voiture vous permet de rejoindre certains lieux.
  \item [Grand escalier] C'est l'endroit où vous arrivez à Buckingham Palace.
  \item [Salle de réception] Là où la crise du corgi royal sera expliquée.
  \item [Salle de l'ESIEE] C'est dans cette salle de l'ESIEE que vous avez lancé ce jeu.
\end{description}

\subsection{Personnages}

De la même façon, cette liste ne comprend que les personnages essentiels au scénario. Certains personnages non-joueurs ne sont pas listés ici.

\begin{description}[leftmargin=!,labelwidth=\widthof{\bfseries Le Compilateur}]
  \item [Murphy Law] Le détective et aussi le personnage que vous incarnez. Son rôle est de mener l'enquête pour comprendre par quelles circonstances Le Joueur s'est retrouvé ici.
  \item [Le Narrateur] La voix que vous entendez quand vous jouez. Le Narrateur permet de décrire les scènes \& situations sans sortir de la narration. 
  \item [Le Joueur] C'est vous ! Cependant, Le Joueur est paradoxalement un personnage non jouable qui vous représente tout au long de  l'histoire dans le cadre de la méta-narration.
  \item [Le Compilateur] Le compilateur Java est le grand méchant de l'histoire. Son rôle, manipuler la structure du jeu pour que l'étudiant n'ait pas une note à la hauteur de son travail.
\end{description}

\section{Situations gagnantes et perdantes}

Le Joueur et Murphy Law seront confrontés à des situations de crises où des choix et décisions devront être prises, certains pourront entraîner la mort ou l'immobilisation des protagonistes et donc faire gagner Le Compilateur.\\
La liste des situations perdantes est la suivante :

\begin{description}[align=left,leftmargin=!,labelwidth=\widthof{\bfseries A Buckingham Palace}]
  \item [A Buckingham Palace] \begin{itemize}
    \item Vous ne retrouvez pas le corgi royal.
    \item Vous essayez d'inspecter la Reine d'Angleterre.
  \end{itemize}
\end{description}

\section{Commentaires}

Murphy Law est une création originale de \href{http://scp-wiki.wikidot.com/murphy-law-hub}{la Fondation SCP}. Le personnage, les œuvres associées et ce jeu sont tous proposés sous licence \emph{Creative Commons Attribution-ShareAlike 3.0}


\chapter{Exercices}

% The first really interesting exercise to write is 7.5. 
% We initialize our counters to match this situation.
\setcounter{section}{7}
\setcounter{exercise}{4}


\begin{exercise}[subtitle=printLocationInfo]

En ré-usinant le code de l'affichage de la localisation et des sorties en une fonction, on s'assure de ne pas répéter cette partie à plusieurs endroits.

\begin{minted}{java}
private void printLocationInfo() {
    Room vCurrent = this.aCurrentRoom;
    System.out.printf("You are %s%n", vCurrent.getDescription());
   
    System.out.print("Exits: ");
    if (vCurrent.aEastExit != null) System.out.print("east ");
    if (vCurrent.aNorthExit != null) System.out.print("north ");
    if (vCurrent.aSouthExit != null) System.out.print("south ");
    if (vCurrent.aWestExit != null) System.out.print("west ");
    System.out.println();
}
\end{minted}
\end{exercise}

\begin{exercise}[subtitle=getExit]

Dans cet exercice, on se rend compte que le système "un attribut = une sortie" n'est pas le plus optimal (imaginons un hub ayant une dizaines de sorties par exemple, ce qui deviendrait problématique pour la lisibilité et la maintenance du code). L'idée étant de limiter le couplage entre la classe \verb|Room| et les autres classes. Pour cela, on cherchera à limiter la dépendance aux attributs de Room et plutôt passer par une fonction pour récupérer les sorties, ce qui permet de ne pas avoir à se soucier de l'implémentation du côté de \verb|Room|.\\ 

\textbf{Notes:} Notons qu'il reste un problème dans \verb|printLocationInfo| à cause de ce changement.

\begin{minted}{java}
/**
 * Retrieves the Room associated with the exit
 * in the requested direction.
 * @param pDirection the direction of the exit.
 * @return the room associated with the exit.
 */
public Room getExit(final String pDirection) {
    switch (pDirection) {
        case "north":
            return this.aNorthExit;

        case "east":
            return this.aEastExit;

        case "south":
            return this.aSouthExit;

        case "west":
            return this.aWestExit;

        default:
            return null;
    }
}
\end{minted}
\end{exercise}

\begin{exercise}[subtitle=getExitString]
Le dernier changement a impacté la façon dont \verb|printLocationInfo| fonctionne. Pour le résoudre, on écrit une nouvelle méthode \verb|getExitString| et, fort de ce changement, on ré-usine \verb|printLocationInfo|.

\begin{minted}{java}
/**
 * Gets all existing exits.
 * @return a string with the possibles exits.
 */
public String getExitString() {
    String vResult = "Exits: ";

    if (this.aEastExit != null) vResult += "east ";
    if (this.aNorthExit != null) vResult += "north ";
    if (this.aSouthExit != null) vResult += "south ";
    if (this.aWestExit != null) vResult += "west";

    return vResult;
}

/**
 * Prints the location informations.
 */
private void printLocationInfo() {
    Room vCurrent = this.aCurrentRoom;

    System.out.printf("You are %s%n", vCurrent.getDescription());
    System.out.println(vCurrent.getExitString());
}
\end{minted}
\end{exercise}

\begin{exercise}[subtitle=HashMap et setExit]

Maintenant que le couplage entre \verb|Room| et \verb|Game| est faible, on peut remplacer les détails de l'implémentation sans risquer de casser quelque chose. On utilise une structure de données \verb|HashMap| et on doit changer les méthodes de \verb|Room| en conséquence. On en profite aussi pour remplacer \verb|setExits|, devenue inutile, par \verb|setExit|.

\begin{minted}{java}
/**
 * Set an exit of the room
 * @param pDirection the direction of the exit
 * @param pExit the Room to which the exit leads
 */
public void setExit(final String pDirection, final Room pExit) {
    this.aExits.put(pDirection, pExit);
}

/**
 * Retrieves the Room associated with the exit in the requested direction.
 *
 * @param pDirection the direction of the exit.
 * @return the room associated with the exit.
 */
public Room getExit(final String pDirection) {
    return this.aExits.get(pDirection);
}
\end{minted}
\end{exercise}

\begin{exercise}[subtitle=keySet]

\verb|getExitString| doit elle aussi être modifiée. Plutôt que de tester la présence de certaines valeurs dans la \verb|HashMap| (du type "north", "east", "down", "up"...), on peut énumérer les différentes clés qui composent la \verb|HashMap| des sorties.

\begin{minted}{java}
/**
 * Gets all existing exits of the room.
 *
 * @return a string with the possibles exits.
 */
public String getExitString() {
    String vResult = "Exits : ";
    for (String vExit : this.aExits.keySet())
        vResult += vExit + " ";

    return vResult;
}
\end{minted}
\end{exercise}

\begin{exercise}[subtitle=Fonctionnement de keySet]

Reprenons le code intéressant de l'exercice précédent et intéressons-nous à son fonctionnement.

\begin{minted}{java}
for (String vExit : this.aExits.keySet())
    vResult += vExit + " ";
\end{minted}

La différence entre un \verb|Set| et liste normale est que le \verb|Set| ne peut pas contenir deux mêmes éléments.
\end{exercise}

\begin{exercise}[subtitle=getLongDescription]

Toujours dans la logique de la conception dirigée par les responsabilités, on déplace la création de la description dans la classe \verb|Room|.

\begin{minted}{java}
/**
 * Gets a long description of this room.
 * @return the complete description.
 */
public String getLongDescription() {
    return "You are " + this.aDescription + ".\n" + this.getExitString();
}
\end{minted}

Et on change \verb|Game| en conséquence.

\begin{minted}{java}
/**
 * Prints the location informations.
 */
private void printLocationInfo() {
    Room vCurrent = this.aCurrentRoom;
    System.out.println(vCurrent.getLongDescription());
}
\end{minted}
\end{exercise}

\setcounter{exercise}{13}

\begin{exercise}[subtitle=look]

L'ajout de la commande \verb|Look| se traduit pas plusieurs changements, déjà en mettant le mot de la commande dans \verb|CommandWords|.

\begin{minted}{java}
// a static constant array that will hold the valid commands words
private final static String[] aValidCommands = { "go", "quit", "help", "look" };
\end{minted}

Il faut aussi renseigner le nouveau mot de la commande dans \mintinline{java}{processCommand(final Command pCommand)}.

\begin{minted}{java}
/**
 * Process a Command object.
 *
 * @param pCommand the command to be processed.
 * @return if the program should quit.
 * @see Command
 */
private boolean processCommand(final Command pCommand) {
    if (pCommand.isUnknown()) {
        System.out.println("I don't know what you mean...");
        return false;
    }

    switch (pCommand.getCommandWord()) {
        case "help":
            this.printHelp();
            return false;

        case "quit":
            return this.quit(pCommand);

        case "go":
            this.goRoom(pCommand);
            return false;

        case "look":
            this.look();
            return false;

        default:
            System.out.println("I don't know what you mean...");
            return false;
    }
}
\end{minted}

On remarque aussi que la méthode \verb|look()| fait, pour l'instant, la même chose que \verb|printLocationInfo()|. 
\end{exercise}

\begin{exercise}[subtitle=Commande inspect]
 
 J'ai choisi d'implémenter une commande nommée \verb|inspect <something>| qui permettra d'inspecter des objet présent dans la pièce où se trouve le joueur. Pour ajouter cette commande, on modifie \verb|CommandWords|.
 
\begin{minted}{java}
private final static String[] aValidCommands = { "go", "quit", "help", "look", "inspect" };
\end{minted}

Et on doit modifier la méthode \verb|processCommand| de \verb|Game| ainsi que créer la méthode pour gérer cette commande.

\begin{minted}{java}
private boolean processCommand(final Command pCommand) {
    [...]

    switch (pCommand.getCommandWord()) {
        case "inspect":
            this.inspect(pCommand);
            return false;

        [...]
    }
}
\end{minted}

\begin{minted}{java}
/**
 * Handles the inspect command.
 *
 * @param pCommand the inspect command to be processed.
 */
private void inspect(Command pCommand) {
    System.out.printf("Nothing to inspect here.");
}
\end{minted}

\textbf{Note:} On utilise ici \verb|[...]| pour signaler les parties du code inutile à montrer car n'ayant pas changées entre les exercices.

\end{exercise}


\begin{exercise}[subtitle=showAll et showCommands]

Dans cet exercice, on rend l'affichage des commandes dans la méthode \verb|printHelp| dynamique en créant un méthode d'énumération des commandes dans \verb|CommandWords|.


\begin{minted}{java}
/**
 * Shows all possible command word on System.out.
 */
public void showAll() {
    System.out.print("\t");
    for (String command : CommandWords.aValidCommands) {
        System.out.print(command + " ");
    }
    System.out.println();
}
\end{minted}

\textbf{Note:} On observe que la méthode \verb|showAll| pourrait être déclarée comme \verb|static| car ne dépendant que de \verb|CommandWords.aValidCommands| qui est un attribut statique de la classe \verb|CommandWords|.\\

On crée aussi un moyen de l'appeler depuis \verb|Game| en passant par \verb|Parser|.

\begin{minted}{java}
// Dans Parser.java

/**
 * Shows all the valid command words.
 */
public void showCommands() {
    this.aValidCommands.showAll();
}
\end{minted}

\begin{minted}{java}
// Dans Game.java

/**
 * Prints a little help text.
 */
private void printHelp() {
    System.out.println("You are lost. You are alone.");
    System.out.println("You wander around at the university.");
    System.out.println("Your command words are:");
    this.aParser.showCommands();
}
\end{minted}
\end{exercise}

\begin{exercise}[subtitle=Changer Game ?]

Malgré toutes nos modifications, si l'on ajoute une nouvelle commande au jeu, il faudra quand même modifier la classe \verb|Game|. En effet, la méthode \verb|processCommand| contient un \verb|switch| dont on doit ajouter une nouvelle branche pour chaque nouvelle commande.

\end{exercise}

\begin{exercise}[subtitle=getCommandList]

Dans cet exercice, on poursuit notre travail sur le modèle de la conception axée sur la responsabilité. Pour le cas de \verb|showAll|, plutôt qu'afficher la liste des commandes disponibles, on préférera générer un \verb|String| pour ne pas imposer un affichage spécifique (notamment via \verb|System.out|).

\begin{minted}{java}
/**
 * Get all possible command words.
 */
public String getCommandList() {
    String vResult = "";
    for (String command : CommandWords.aValidCommands) {
        vResult += command + " ";
    }

    return vResult;
}
\end{minted}

On modifie la cascade crée aux exercices d'avant pour refléter ce changement.

\begin{minted}{java}
// Dans Parser.java

/**
 * Gets all the valid command words.
 */
public String getCommands() {
    return this.aValidCommands.getCommandList();
}
\end{minted}

\begin{minted}{java}
// Dans Game.java

/**
 * Prints a little help text.
 */
private void printHelp() {
    System.out.println("You are lost. You are alone.");
    System.out.println("You wander around at the university.");
    System.out.println("Your command words are:");
    System.out.println("\t" + this.aParser.getCommands()); // "\t" représente une tabulation
}
\end{minted}
\end{exercise}

\chapter{Mode d'emploi}

\chapter{Plagiat}

\end{document}
